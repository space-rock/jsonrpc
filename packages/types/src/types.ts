/**
 * This file was auto-generated by a script.
 * Do not make direct changes to the file.
 */
export type AccessKey = {
  /**
   * Format: uint64
   * @description Nonce for this access key, used for tx nonce generation. When access key is created, nonce
   *     is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.
   *     See <https://github.com/near/nearcore/issues/3779> for more details.
   */
  nonce: number;
  /** @description Defines permissions for this access key. */
  permission: AccessKeyPermission;
};
export type AccessKeyCreationConfigView = {
  /** @description Base cost of creating a full access access-key. */
  fullAccessCost: Fee;
  /** @description Base cost of creating an access-key restricted to specific functions. */
  functionCallCost: Fee;
  /** @description Cost per byte of method_names of creating a restricted access-key. */
  functionCallCostPerByte: Fee;
};
export type AccessKeyInfoView = {
  accessKey: AccessKeyView;
  publicKey: PublicKey;
};
export type AccessKeyList = {
  keys: AccessKeyInfoView[];
};
export type AccessKeyPermission =
  | {
      FunctionCall: FunctionCallPermission;
    }
  | 'FullAccess';
export type AccessKeyPermissionView =
  | 'FullAccess'
  | {
      FunctionCall: {
        allowance?: string | null;
        methodNames: string[];
        receiverId: string;
      };
    };
export type AccessKeyView = {
  /** Format: uint64 */
  nonce: number;
  permission: AccessKeyPermissionView;
};
export type AccountCreationConfigView = {
  /**
   * Format: uint8
   * @description The minimum length of the top-level account ID that is allowed to be created by any account.
   */
  minAllowedTopLevelAccountLength: number;
  /** @description The account ID of the account registrar. This account ID allowed to create top-level
   *     accounts of any valid length. */
  registrarAccountId: AccountId;
};
export type AccountDataView = {
  /** @description Account key of the validator signing this AccountData. */
  accountKey: PublicKey;
  /** @description ID of the node that handles the account key (aka validator key). */
  peerId: PublicKey;
  /** @description Proxy nodes that are directly connected to the validator node
   *     (this list may include the validator node itself).
   *     TIER1 nodes should connect to one of the proxies to sent TIER1
   *     messages to the validator. */
  proxies: Tier1ProxyView[];
  /** @description UTC timestamp of when the AccountData has been signed. */
  timestamp: string;
};
export type AccountId = string;
export type AccountIdValidityRulesVersion = number;
export type AccountInfo = {
  accountId: AccountId;
  amount: string;
  publicKey: PublicKey;
};
export type AccountView = {
  amount: string;
  codeHash: CryptoHash;
  globalContractAccountId?: AccountId | null;
  globalContractHash?: CryptoHash | null;
  locked: string;
  /**
   * Format: uint64
   * @description TODO(2271): deprecated.
   * @default 0
   */
  storagePaidAt: number;
  /** Format: uint64 */
  storageUsage: number;
};
export type AccountWithPublicKey = {
  accountId: AccountId;
  publicKey: PublicKey;
};
export type Action =
  | {
      CreateAccount: CreateAccountAction;
    }
  | {
      DeployContract: DeployContractAction;
    }
  | {
      FunctionCall: FunctionCallAction;
    }
  | {
      Transfer: TransferAction;
    }
  | {
      Stake: StakeAction;
    }
  | {
      AddKey: AddKeyAction;
    }
  | {
      DeleteKey: DeleteKeyAction;
    }
  | {
      DeleteAccount: DeleteAccountAction;
    }
  | {
      Delegate: SignedDelegateAction;
    }
  | {
      DeployGlobalContract: DeployGlobalContractAction;
    }
  | {
      UseGlobalContract: UseGlobalContractAction;
    };
export type ActionCreationConfigView = {
  /** @description Base cost of adding a key. */
  addKeyCost: AccessKeyCreationConfigView;
  /** @description Base cost of creating an account. */
  createAccountCost: Fee;
  /** @description Base cost for processing a delegate action.
   *
   *     This is on top of the costs for the actions inside the delegate action. */
  delegateCost: Fee;
  /** @description Base cost of deleting an account. */
  deleteAccountCost: Fee;
  /** @description Base cost of deleting a key. */
  deleteKeyCost: Fee;
  /** @description Base cost of deploying a contract. */
  deployContractCost: Fee;
  /** @description Cost per byte of deploying a contract. */
  deployContractCostPerByte: Fee;
  /** @description Base cost of calling a function. */
  functionCallCost: Fee;
  /** @description Cost per byte of method name and arguments of calling a function. */
  functionCallCostPerByte: Fee;
  /** @description Base cost of staking. */
  stakeCost: Fee;
  /** @description Base cost of making a transfer. */
  transferCost: Fee;
};
export type ActionError = {
  /**
   * Format: uint64
   * @description Index of the failed action in the transaction.
   *     Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`
   */
  index?: number | null;
  /** @description The kind of ActionError happened */
  kind: ActionErrorKind;
};
export type ActionErrorKind =
  | {
      AccountAlreadyExists: {
        accountId: AccountId;
      };
    }
  | {
      AccountDoesNotExist: {
        accountId: AccountId;
      };
    }
  | {
      CreateAccountOnlyByRegistrar: {
        accountId: AccountId;
        predecessorId: AccountId;
        registrarAccountId: AccountId;
      };
    }
  | {
      CreateAccountNotAllowed: {
        accountId: AccountId;
        predecessorId: AccountId;
      };
    }
  | {
      ActorNoPermission: {
        accountId: AccountId;
        actorId: AccountId;
      };
    }
  | {
      DeleteKeyDoesNotExist: {
        accountId: AccountId;
        publicKey: PublicKey;
      };
    }
  | {
      AddKeyAlreadyExists: {
        accountId: AccountId;
        publicKey: PublicKey;
      };
    }
  | {
      DeleteAccountStaking: {
        accountId: AccountId;
      };
    }
  | {
      LackBalanceForState: {
        /** @description An account which needs balance */
        accountId: AccountId;
        /** @description Balance required to complete an action. */
        amount: string;
      };
    }
  | {
      TriesToUnstake: {
        accountId: AccountId;
      };
    }
  | {
      TriesToStake: {
        accountId: AccountId;
        balance: string;
        locked: string;
        stake: string;
      };
    }
  | {
      InsufficientStake: {
        accountId: AccountId;
        minimumStake: string;
        stake: string;
      };
    }
  | {
      FunctionCallError: FunctionCallError;
    }
  | {
      NewReceiptValidationError: ReceiptValidationError;
    }
  | {
      OnlyImplicitAccountCreationAllowed: {
        accountId: AccountId;
      };
    }
  | {
      DeleteAccountWithLargeState: {
        accountId: AccountId;
      };
    }
  | 'DelegateActionInvalidSignature'
  | {
      DelegateActionSenderDoesNotMatchTxReceiver: {
        receiverId: AccountId;
        senderId: AccountId;
      };
    }
  | 'DelegateActionExpired'
  | {
      DelegateActionAccessKeyError: InvalidAccessKeyError;
    }
  | {
      DelegateActionInvalidNonce: {
        /** Format: uint64 */
        akNonce: number;
        /** Format: uint64 */
        delegateNonce: number;
      };
    }
  | {
      DelegateActionNonceTooLarge: {
        /** Format: uint64 */
        delegateNonce: number;
        /** Format: uint64 */
        upperBound: number;
      };
    }
  | {
      GlobalContractDoesNotExist: {
        identifier: GlobalContractIdentifier;
      };
    };
export type ActionView =
  | 'CreateAccount'
  | {
      DeployContract: {
        /** Format: bytes */
        code: string;
      };
    }
  | {
      FunctionCall: {
        args: FunctionArgs;
        deposit: string;
        /** Format: uint64 */
        gas: number;
        methodName: string;
      };
    }
  | {
      Transfer: {
        deposit: string;
      };
    }
  | {
      Stake: {
        publicKey: PublicKey;
        stake: string;
      };
    }
  | {
      AddKey: {
        accessKey: AccessKeyView;
        publicKey: PublicKey;
      };
    }
  | {
      DeleteKey: {
        publicKey: PublicKey;
      };
    }
  | {
      DeleteAccount: {
        beneficiaryId: AccountId;
      };
    }
  | {
      Delegate: {
        delegateAction: DelegateAction;
        signature: Signature;
      };
    }
  | {
      DeployGlobalContract: {
        /** Format: bytes */
        code: string;
      };
    }
  | {
      DeployGlobalContractByAccountId: {
        /** Format: bytes */
        code: string;
      };
    }
  | {
      UseGlobalContract: {
        codeHash: CryptoHash;
      };
    }
  | {
      UseGlobalContractByAccountId: {
        accountId: AccountId;
      };
    };
export type ActionsValidationError =
  | 'DeleteActionMustBeFinal'
  | {
      TotalPrepaidGasExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        totalPrepaidGas: number;
      };
    }
  | {
      TotalNumberOfActionsExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        totalNumberOfActions: number;
      };
    }
  | {
      AddKeyMethodNamesNumberOfBytesExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        totalNumberOfBytes: number;
      };
    }
  | {
      AddKeyMethodNameLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | 'IntegerOverflow'
  | {
      InvalidAccountId: {
        accountId: string;
      };
    }
  | {
      ContractSizeExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        size: number;
      };
    }
  | {
      FunctionCallMethodNameLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      FunctionCallArgumentsLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      UnsuitableStakingKey: {
        publicKey: PublicKey;
      };
    }
  | 'FunctionCallZeroAttachedGas'
  | 'DelegateActionMustBeOnlyOne'
  | {
      UnsupportedProtocolFeature: {
        protocolFeature: string;
        /** Format: uint32 */
        version: number;
      };
    };
export type AddKeyAction = {
  /** @description An access key with the permission */
  accessKey: AccessKey;
  /** @description A public key which will be associated with an access_key */
  publicKey: PublicKey;
};
export type BandwidthRequest = {
  /** @description Bitmap which describes what values of bandwidth are requested. */
  requestedValuesBitmap: BandwidthRequestBitmap;
  /**
   * Format: uint16
   * @description Requesting bandwidth to this shard.
   */
  toShard: number;
};
export type BandwidthRequestBitmap = {
  data: number[];
};
export type BandwidthRequests = {
  V1: BandwidthRequestsV1;
};
export type BandwidthRequestsV1 = {
  requests: BandwidthRequest[];
};
export type BlockHeaderInnerLiteView = {
  /** @description The merkle root of all the block hashes */
  blockMerkleRoot: CryptoHash;
  /** @description The epoch to which the block that is the current known head belongs */
  epochId: CryptoHash;
  /** Format: uint64 */
  height: number;
  /** @description The hash of the block producers set for the next epoch */
  nextBpHash: CryptoHash;
  /** @description The epoch that will follow the current epoch */
  nextEpochId: CryptoHash;
  outcomeRoot: CryptoHash;
  prevStateRoot: CryptoHash;
  /**
   * Format: uint64
   * @description Legacy json number. Should not be used.
   */
  timestamp: number;
  timestampNanosec: string;
};
export type BlockHeaderView = {
  approvals: (Signature | null)[];
  blockBodyHash?: CryptoHash | null;
  blockMerkleRoot: CryptoHash;
  /** Format: uint64 */
  blockOrdinal?: number | null;
  challengesResult: SlashedValidator[];
  challengesRoot: CryptoHash;
  chunkEndorsements?: number[][] | null;
  chunkHeadersRoot: CryptoHash;
  chunkMask: boolean[];
  chunkReceiptsRoot: CryptoHash;
  chunkTxRoot: CryptoHash;
  /** Format: uint64 */
  chunksIncluded: number;
  epochId: CryptoHash;
  epochSyncDataHash?: CryptoHash | null;
  gasPrice: string;
  hash: CryptoHash;
  /** Format: uint64 */
  height: number;
  lastDsFinalBlock: CryptoHash;
  lastFinalBlock: CryptoHash;
  /** Format: uint32 */
  latestProtocolVersion: number;
  nextBpHash: CryptoHash;
  nextEpochId: CryptoHash;
  outcomeRoot: CryptoHash;
  /** @description The hash of the previous Block */
  prevHash: CryptoHash;
  /** Format: uint64 */
  prevHeight?: number | null;
  prevStateRoot: CryptoHash;
  randomValue: CryptoHash;
  /** @description TODO(2271): deprecated. */
  rentPaid: string;
  /** @description Signature of the block producer. */
  signature: Signature;
  /**
   * Format: uint64
   * @description Legacy json number. Should not be used.
   */
  timestamp: number;
  timestampNanosec: string;
  totalSupply: string;
  validatorProposals: ValidatorStakeView[];
  /** @description TODO(2271): deprecated. */
  validatorReward: string;
};
export type BlockId = number | CryptoHash;
export type BlockStatusView = {
  hash: CryptoHash;
  /** Format: uint64 */
  height: number;
};
export type CallResult = {
  logs: string[];
  result: number[];
};
export type CatchupStatusView = {};
export type ChunkDistributionNetworkConfig = {
  enabled: boolean;
  uris: ChunkDistributionUris;
};
export type ChunkDistributionUris = {
  /** @description URI for pulling chunks from the stream. */
  get: string;
  /** @description URI for publishing chunks to the stream. */
  set: string;
};
export type ChunkHeaderView = {
  balanceBurnt: string;
  bandwidthRequests?: BandwidthRequests | null;
  chunkHash: CryptoHash;
  congestionInfo?: CongestionInfoView | null;
  /** Format: uint64 */
  encodedLength: number;
  encodedMerkleRoot: CryptoHash;
  /** Format: uint64 */
  gasLimit: number;
  /** Format: uint64 */
  gasUsed: number;
  /** Format: uint64 */
  heightCreated: number;
  /** Format: uint64 */
  heightIncluded: number;
  outcomeRoot: CryptoHash;
  outgoingReceiptsRoot: CryptoHash;
  prevBlockHash: CryptoHash;
  prevStateRoot: CryptoHash;
  /** @description TODO(2271): deprecated. */
  rentPaid: string;
  shardId: ShardId;
  signature: Signature;
  txRoot: CryptoHash;
  validatorProposals: ValidatorStakeView[];
  /** @description TODO(2271): deprecated. */
  validatorReward: string;
};
export type CompilationError =
  | {
      CodeDoesNotExist: {
        accountId: AccountId;
      };
    }
  | {
      PrepareError: PrepareError;
    }
  | {
      WasmerCompileError: {
        msg: string;
      };
    };
export type CongestionControlConfigView = {
  /**
   * Format: uint64
   * @description How much gas the chosen allowed shard can send to a 100% congested shard.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  allowedShardOutgoingGas: number;
  /**
   * Format: uint64
   * @description How much gas in delayed receipts of a shard is 100% incoming congestion.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  maxCongestionIncomingGas: number;
  /**
   * Format: uint64
   * @description How much memory space of all delayed and buffered receipts in a shard is
   *     considered 100% congested.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  maxCongestionMemoryConsumption: number;
  /**
   * Format: uint64
   * @description How many missed chunks in a row in a shard is considered 100% congested.
   */
  maxCongestionMissedChunks: number;
  /**
   * Format: uint64
   * @description How much gas in outgoing buffered receipts of a shard is 100% congested.
   *
   *     Outgoing congestion contributes to overall congestion, which reduces how
   *     much other shards are allowed to forward to this shard.
   */
  maxCongestionOutgoingGas: number;
  /**
   * Format: uint64
   * @description The maximum amount of gas attached to receipts a shard can forward to
   *     another shard per chunk.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  maxOutgoingGas: number;
  /**
   * Format: uint64
   * @description The maximum amount of gas in a chunk spent on converting new transactions to
   *     receipts.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  maxTxGas: number;
  /**
   * Format: uint64
   * @description The minimum gas each shard can send to a shard that is not fully congested.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  minOutgoingGas: number;
  /**
   * Format: uint64
   * @description The minimum amount of gas in a chunk spent on converting new transactions
   *     to receipts, as long as the receiving shard is not congested.
   *
   *     See [`CongestionControlConfig`] for more details.
   */
  minTxGas: number;
  /**
   * Format: uint64
   * @description Large size limit for outgoing receipts to a shard, used when it's safe
   *     to send a lot of receipts without making the state witness too large.
   *     It limits the total sum of outgoing receipts, not individual receipts.
   */
  outgoingReceiptsBigSizeLimit: number;
  /**
   * Format: uint64
   * @description The standard size limit for outgoing receipts aimed at a single shard.
   *     This limit is pretty small to keep the size of source_receipt_proofs under control.
   *     It limits the total sum of outgoing receipts, not individual receipts.
   */
  outgoingReceiptsUsualSizeLimit: number;
  /**
   * Format: double
   * @description How much congestion a shard can tolerate before it stops all shards from
   *     accepting new transactions with the receiver set to the congested shard.
   */
  rejectTxCongestionThreshold: number;
};
export type CongestionInfoView = {
  /** Format: uint16 */
  allowedShard: number;
  bufferedReceiptsGas: string;
  delayedReceiptsGas: string;
  /** Format: uint64 */
  receiptBytes: number;
};
export type ContractCodeView = {
  codeBase64: string;
  hash: CryptoHash;
};
export type CostGasUsed = {
  cost: string;
  /** @description Either ACTION_COST or WASM_HOST_COST. */
  costCategory: string;
  gasUsed: string;
};
export type CreateAccountAction = {};
export type CryptoHash = string;
export type CurrentEpochValidatorInfo = {
  accountId: AccountId;
  isSlashed: boolean;
  /** Format: uint64 */
  numExpectedBlocks: number;
  /**
   * Format: uint64
   * @default 0
   */
  numExpectedChunks: number;
  /**
   * @description Number of chunks this validator was expected to produce in each shard.
   *     Each entry in the array corresponds to the shard in the `shards_produced` array.
   * @default []
   */
  numExpectedChunksPerShard: number[];
  /**
   * Format: uint64
   * @default 0
   */
  numExpectedEndorsements: number;
  /**
   * @description Number of chunks this validator was expected to validate and endorse in each shard.
   *     Each entry in the array corresponds to the shard in the `shards_endorsed` array.
   * @default []
   */
  numExpectedEndorsementsPerShard: number[];
  /** Format: uint64 */
  numProducedBlocks: number;
  /**
   * Format: uint64
   * @default 0
   */
  numProducedChunks: number;
  /** @default [] */
  numProducedChunksPerShard: number[];
  /**
   * Format: uint64
   * @default 0
   */
  numProducedEndorsements: number;
  /** @default [] */
  numProducedEndorsementsPerShard: number[];
  publicKey: PublicKey;
  /** @description Shards this validator is assigned to as chunk producer in the current epoch. */
  shards: ShardId[];
  /**
   * @description Shards this validator is assigned to as chunk validator in the current epoch.
   * @default []
   */
  shardsEndorsed: ShardId[];
  stake: string;
};
export type DataReceiptCreationConfigView = {
  /** @description Base cost of creating a data receipt.
   *     Both `send` and `exec` costs are burned when a new receipt has input dependencies. The gas
   *     is charged for each input dependency. The dependencies are specified when a receipt is
   *     created using `promise_then` and `promise_batch_then`.
   *     NOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.
   *     Even if the last action is not a function call (in case of success it will return empty
   *     value). */
  baseCost: Fee;
  /** @description Additional cost per byte sent.
   *     Both `send` and `exec` costs are burned when a function call finishes execution and returns
   *     `N` bytes of data to every output dependency. For each output dependency the cost is
   *     `(send(sir) + exec()) * N`. */
  costPerByte: Fee;
};
export type DataReceiverView = {
  dataId: CryptoHash;
  receiverId: AccountId;
};
export type DelegateAction = {
  /** @description List of actions to be executed.
   *
   *     With the meta transactions MVP defined in NEP-366, nested
   *     DelegateActions are not allowed. A separate type is used to enforce it. */
  actions: NonDelegateAction[];
  /**
   * Format: uint64
   * @description The maximal height of the block in the blockchain below which the given DelegateAction is valid.
   */
  maxBlockHeight: number;
  /**
   * Format: uint64
   * @description Nonce to ensure that the same delegate action is not sent twice by a
   *     relayer and should match for given account's `public_key`.
   *     After this action is processed it will increment.
   */
  nonce: number;
  /** @description Public key used to sign this delegated action. */
  publicKey: PublicKey;
  /** @description Receiver of the delegated actions. */
  receiverId: AccountId;
  /** @description Signer of the delegated actions */
  senderId: AccountId;
};
export type DeleteAccountAction = {
  beneficiaryId: AccountId;
};
export type DeleteKeyAction = {
  /** @description A public key associated with the access_key to be deleted. */
  publicKey: PublicKey;
};
export type DeployContractAction = {
  /** @description WebAssembly binary */
  code: string;
};
export type DeployGlobalContractAction = {
  /** @description WebAssembly binary */
  code: string;
  deployMode: GlobalContractDeployMode;
};
export type DetailedDebugStatus = {
  /** Format: uint64 */
  blockProductionDelayMillis: number;
  catchupStatus: CatchupStatusView[];
  currentHeadStatus: BlockStatusView;
  currentHeaderHeadStatus: BlockStatusView;
  networkInfo: NetworkInfoView;
  syncStatus: string;
};
export type Direction = 'Left' | 'Right';
export type DumpConfig = {
  /** @description Location of a json file with credentials allowing write access to the bucket. */
  credentialsFile?: string | null;
  /** @description How often to check if a new epoch has started.
   *     Feel free to set to `None`, defaults are sensible. */
  iterationDelay?: DurationAsStdSchemaProvider | null;
  /** @description Specifies where to write the obtained state parts. */
  location: ExternalStorageLocation;
  /** @description Use in case a node that dumps state to the external storage
   *     gets in trouble. */
  restartDumpForShards?: ShardId[] | null;
};
export type DurationAsStdSchemaProvider = {
  /** Format: int32 */
  nanos: number;
  /** Format: int64 */
  secs: number;
};
export type EpochId = CryptoHash;
export type EpochSyncConfig = {
  /**
   * @description If true, even if the node started from genesis, it will not perform epoch sync.
   *     There should be no reason to set this flag in production, because on both mainnet
   *     and testnet it would be infeasible to catch up from genesis without epoch sync.
   * @default false
   */
  disableEpochSyncForBootstrapping: boolean;
  /**
   * Format: uint64
   * @description This serves as two purposes: (1) the node will not epoch sync and instead resort to
   *     header sync, if the genesis block is within this many blocks from the current block;
   *     (2) the node will reject an epoch sync proof if the provided proof is for an epoch
   *     that is more than this many blocks behind the current block.
   */
  epochSyncHorizon: number;
  /**
   * @description If true, the node will ignore epoch sync requests from the network. It is strongly
   *     recommended not to set this flag, because it will prevent other nodes from
   *     bootstrapping. This flag is only included as a kill-switch and may be removed in a
   *     future release. Please note that epoch sync requests are heavily rate limited and
   *     cached, and therefore should not affect the performance of the node or introduce
   *     any non-negligible increase in network traffic.
   * @default false
   */
  ignoreEpochSyncNetworkRequests: boolean;
  /** @description Timeout for epoch sync requests. The node will continue retrying indefinitely even
   *     if this timeout is exceeded. */
  timeoutForEpochSync: DurationAsStdSchemaProvider;
};
export type ExecutionMetadataView = {
  gasProfile?: CostGasUsed[] | null;
  /** Format: uint32 */
  version: number;
};
export type ExecutionOutcomeView = {
  /** @description The id of the account on which the execution happens. For transaction this is signer_id,
   *     for receipt this is receiver_id. */
  executorId: AccountId;
  /**
   * Format: uint64
   * @description The amount of the gas burnt by the given transaction or receipt.
   */
  gasBurnt: number;
  /** @description Logs from this transaction or receipt. */
  logs: string[];
  /**
   * @description Execution metadata, versioned
   * @default {
   *       "version": 1
   *     }
   */
  metadata: ExecutionMetadataView;
  /** @description Receipt IDs generated by this transaction or receipt. */
  receiptIds: CryptoHash[];
  /** @description Execution status. Contains the result in case of successful execution. */
  status: ExecutionStatusView;
  /** @description The amount of tokens burnt corresponding to the burnt gas amount.
   *     This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
   *     the prepaid gas price might be lower than the actual gas price and it creates a deficit.
   *     `tokens_burnt` also contains the penalty subtracted from refunds, while
   *     `gas_burnt` only contains the gas that we actually burn for the execution. */
  tokensBurnt: string;
};
export type ExecutionOutcomeWithIdView = {
  blockHash: CryptoHash;
  id: CryptoHash;
  outcome: ExecutionOutcomeView;
  proof: MerklePathItem[];
};
export type ExecutionStatusView =
  | 'Unknown'
  | {
      Failure: TxExecutionError;
    }
  | {
      SuccessValue: string;
    }
  | {
      SuccessReceiptId: CryptoHash;
    };
export type ExtCostsConfigView = {
  /**
   * Format: uint64
   * @description Base cost for multiexp
   */
  altBn128G1MultiexpBase: number;
  /**
   * Format: uint64
   * @description Per element cost for multiexp
   */
  altBn128G1MultiexpElement: number;
  /**
   * Format: uint64
   * @description Base cost for sum
   */
  altBn128G1SumBase: number;
  /**
   * Format: uint64
   * @description Per element cost for sum
   */
  altBn128G1SumElement: number;
  /**
   * Format: uint64
   * @description Base cost for pairing check
   */
  altBn128PairingCheckBase: number;
  /**
   * Format: uint64
   * @description Per element cost for pairing check
   */
  altBn128PairingCheckElement: number;
  /**
   * Format: uint64
   * @description Base cost for calling a host function.
   */
  base: number;
  /** Format: uint64 */
  bls12381G1MultiexpBase: number;
  /** Format: uint64 */
  bls12381G1MultiexpElement: number;
  /** Format: uint64 */
  bls12381G2MultiexpBase: number;
  /** Format: uint64 */
  bls12381G2MultiexpElement: number;
  /** Format: uint64 */
  bls12381MapFp2ToG2Base: number;
  /** Format: uint64 */
  bls12381MapFp2ToG2Element: number;
  /** Format: uint64 */
  bls12381MapFpToG1Base: number;
  /** Format: uint64 */
  bls12381MapFpToG1Element: number;
  /** Format: uint64 */
  bls12381P1DecompressBase: number;
  /** Format: uint64 */
  bls12381P1DecompressElement: number;
  /** Format: uint64 */
  bls12381P1SumBase: number;
  /** Format: uint64 */
  bls12381P1SumElement: number;
  /** Format: uint64 */
  bls12381P2DecompressBase: number;
  /** Format: uint64 */
  bls12381P2DecompressElement: number;
  /** Format: uint64 */
  bls12381P2SumBase: number;
  /** Format: uint64 */
  bls12381P2SumElement: number;
  /** Format: uint64 */
  bls12381PairingBase: number;
  /** Format: uint64 */
  bls12381PairingElement: number;
  /** Format: uint64 */
  contractCompileBase: number;
  /** Format: uint64 */
  contractCompileBytes: number;
  /**
   * Format: uint64
   * @description Base cost of loading a pre-compiled contract
   */
  contractLoadingBase: number;
  /**
   * Format: uint64
   * @description Cost per byte of loading a pre-compiled contract
   */
  contractLoadingBytes: number;
  /**
   * Format: uint64
   * @description Cost of calling ecrecover
   */
  ecrecoverBase: number;
  /**
   * Format: uint64
   * @description Cost of getting ed25519 base
   */
  ed25519VerifyBase: number;
  /**
   * Format: uint64
   * @description Cost of getting ed25519 per byte
   */
  ed25519VerifyByte: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 base
   */
  keccak256Base: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 per byte
   */
  keccak256Byte: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 base
   */
  keccak512Base: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 per byte
   */
  keccak512Byte: number;
  /**
   * Format: uint64
   * @description Cost for calling logging.
   */
  logBase: number;
  /**
   * Format: uint64
   * @description Cost for logging per byte
   */
  logByte: number;
  /**
   * Format: uint64
   * @description Cost for calling `promise_and`
   */
  promiseAndBase: number;
  /**
   * Format: uint64
   * @description Cost for calling `promise_and` for each promise
   */
  promiseAndPerPromise: number;
  /**
   * Format: uint64
   * @description Cost for calling `promise_return`
   */
  promiseReturn: number;
  /**
   * Format: uint64
   * @description Cost for reading trie node from memory
   */
  readCachedTrieNode: number;
  /**
   * Format: uint64
   * @description Base cost for guest memory read
   */
  readMemoryBase: number;
  /**
   * Format: uint64
   * @description Cost for guest memory read
   */
  readMemoryByte: number;
  /**
   * Format: uint64
   * @description Base cost for reading from register
   */
  readRegisterBase: number;
  /**
   * Format: uint64
   * @description Cost for reading byte from register
   */
  readRegisterByte: number;
  /**
   * Format: uint64
   * @description Cost of getting ripemd160 base
   */
  ripemd160Base: number;
  /**
   * Format: uint64
   * @description Cost of getting ripemd160 per message block
   */
  ripemd160Block: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 base
   */
  sha256Base: number;
  /**
   * Format: uint64
   * @description Cost of getting sha256 per byte
   */
  sha256Byte: number;
  /**
   * Format: uint64
   * @description Storage trie check for key existence cost base
   */
  storageHasKeyBase: number;
  /**
   * Format: uint64
   * @description Storage trie check for key existence per key byte
   */
  storageHasKeyByte: number;
  /**
   * Format: uint64
   * @description Create trie range iterator cost per byte of from key.
   */
  storageIterCreateFromByte: number;
  /**
   * Format: uint64
   * @description Create trie prefix iterator cost base
   */
  storageIterCreatePrefixBase: number;
  /**
   * Format: uint64
   * @description Create trie prefix iterator cost per byte.
   */
  storageIterCreatePrefixByte: number;
  /**
   * Format: uint64
   * @description Create trie range iterator cost base
   */
  storageIterCreateRangeBase: number;
  /**
   * Format: uint64
   * @description Create trie range iterator cost per byte of to key.
   */
  storageIterCreateToByte: number;
  /**
   * Format: uint64
   * @description Trie iterator per key base cost
   */
  storageIterNextBase: number;
  /**
   * Format: uint64
   * @description Trie iterator next key byte cost
   */
  storageIterNextKeyByte: number;
  /**
   * Format: uint64
   * @description Trie iterator next key byte cost
   */
  storageIterNextValueByte: number;
  /**
   * Format: uint64
   * @description Storage trie read key overhead base cost, when doing large reads
   */
  storageLargeReadOverheadBase: number;
  /**
   * Format: uint64
   * @description Storage trie read key overhead  per-byte cost, when doing large reads
   */
  storageLargeReadOverheadByte: number;
  /**
   * Format: uint64
   * @description Storage trie read key base cost
   */
  storageReadBase: number;
  /**
   * Format: uint64
   * @description Storage trie read key per byte cost
   */
  storageReadKeyByte: number;
  /**
   * Format: uint64
   * @description Storage trie read value cost per byte cost
   */
  storageReadValueByte: number;
  /**
   * Format: uint64
   * @description Remove key from trie base cost
   */
  storageRemoveBase: number;
  /**
   * Format: uint64
   * @description Remove key from trie per byte cost
   */
  storageRemoveKeyByte: number;
  /**
   * Format: uint64
   * @description Remove key from trie ret value byte cost
   */
  storageRemoveRetValueByte: number;
  /**
   * Format: uint64
   * @description Storage trie write key base cost
   */
  storageWriteBase: number;
  /**
   * Format: uint64
   * @description Storage trie write cost per byte of evicted value.
   */
  storageWriteEvictedByte: number;
  /**
   * Format: uint64
   * @description Storage trie write key per byte cost
   */
  storageWriteKeyByte: number;
  /**
   * Format: uint64
   * @description Storage trie write value per byte cost
   */
  storageWriteValueByte: number;
  /**
   * Format: uint64
   * @description Cost per reading trie node from DB
   */
  touchingTrieNode: number;
  /**
   * Format: uint64
   * @description Base cost of decoding utf16. It's used for `log_utf16`.
   */
  utf16DecodingBase: number;
  /**
   * Format: uint64
   * @description Cost per byte of decoding utf16. It's used for `log_utf16`.
   */
  utf16DecodingByte: number;
  /**
   * Format: uint64
   * @description Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
   */
  utf8DecodingBase: number;
  /**
   * Format: uint64
   * @description Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`.
   */
  utf8DecodingByte: number;
  /**
   * Format: uint64
   * @description Cost of calling `validator_stake`.
   */
  validatorStakeBase: number;
  /**
   * Format: uint64
   * @description Cost of calling `validator_total_stake`.
   */
  validatorTotalStakeBase: number;
  /**
   * Format: uint64
   * @description Base cost for guest memory write
   */
  writeMemoryBase: number;
  /**
   * Format: uint64
   * @description Cost for guest memory write per byte
   */
  writeMemoryByte: number;
  /**
   * Format: uint64
   * @description Base cost for writing into register
   */
  writeRegisterBase: number;
  /**
   * Format: uint64
   * @description Cost for writing byte into register
   */
  writeRegisterByte: number;
  /**
   * Format: uint64
   * @description Base cost for creating a yield promise.
   */
  yieldCreateBase: number;
  /**
   * Format: uint64
   * @description Per byte cost of arguments and method name.
   */
  yieldCreateByte: number;
  /**
   * Format: uint64
   * @description Base cost for resuming a yield receipt.
   */
  yieldResumeBase: number;
  /**
   * Format: uint64
   * @description Per byte cost of resume payload.
   */
  yieldResumeByte: number;
};
export type ExternalStorageConfig = {
  /**
   * Format: uint64
   * @description The number of attempts the node will make to obtain a part from peers in
   *     the network before it fetches from external storage.
   * @default 3
   */
  externalStorageFallbackThreshold: number;
  /** @description Location of state parts. */
  location: ExternalStorageLocation;
  /**
   * Format: uint8
   * @description When fetching state parts from external storage, throttle fetch requests
   *     to this many concurrent requests.
   * @default 25
   */
  numConcurrentRequests: number;
  /**
   * Format: uint8
   * @description During catchup, the node will use a different number of concurrent requests
   *     to reduce the performance impact of state sync.
   * @default 5
   */
  numConcurrentRequestsDuringCatchup: number;
};
export type ExternalStorageLocation =
  | {
      S3: {
        /** @description Location of state dumps on S3. */
        bucket: string;
        /** @description Data may only be available in certain locations. */
        region: string;
      };
    }
  | {
      Filesystem: {
        rootDir: string;
      };
    }
  | {
      GCS: {
        bucket: string;
      };
    };
export type Fee = {
  /**
   * Format: uint64
   * @description Fee for executing the object.
   */
  execution: number;
  /**
   * Format: uint64
   * @description Fee for sending an object potentially across the shards.
   */
  sendNotSir: number;
  /**
   * Format: uint64
   * @description Fee for sending an object from the sender to itself, guaranteeing that it does not leave
   *     the shard.
   */
  sendSir: number;
};
export type FinalExecutionOutcomeView = {
  /** @description The execution outcome of receipts. */
  receiptsOutcome: ExecutionOutcomeWithIdView[];
  /** @description Execution status defined by chain.rs:get_final_transaction_result
   *     FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
   *     FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
   *     FinalExecutionStatus::Failure - the result of the first leaf receipt_id
   *     FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id */
  status: FinalExecutionStatus;
  /** @description Signed Transaction */
  transaction: SignedTransactionView;
  /** @description The execution outcome of the signed transaction. */
  transactionOutcome: ExecutionOutcomeWithIdView;
};
export type FinalExecutionOutcomeWithReceiptView = {
  /** @description Receipts generated from the transaction */
  receipts: ReceiptView[];
  /** @description The execution outcome of receipts. */
  receiptsOutcome: ExecutionOutcomeWithIdView[];
  /** @description Execution status defined by chain.rs:get_final_transaction_result
   *     FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet
   *     FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution
   *     FinalExecutionStatus::Failure - the result of the first leaf receipt_id
   *     FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id */
  status: FinalExecutionStatus;
  /** @description Signed Transaction */
  transaction: SignedTransactionView;
  /** @description The execution outcome of the signed transaction. */
  transactionOutcome: ExecutionOutcomeWithIdView;
};
export type FinalExecutionStatus =
  | 'NotStarted'
  | 'Started'
  | {
      Failure: TxExecutionError;
    }
  | {
      SuccessValue: string;
    };
export type Finality = 'optimistic' | 'near-final' | 'final';
export type FunctionArgs = string;
export type FunctionCallAction = {
  args: string;
  deposit: string;
  /** Format: uint64 */
  gas: number;
  methodName: string;
};
export type FunctionCallError =
  | ('WasmUnknownError' | '_EVMError')
  | {
      CompilationError: CompilationError;
    }
  | {
      LinkError: {
        msg: string;
      };
    }
  | {
      MethodResolveError: MethodResolveError;
    }
  | {
      WasmTrap: WasmTrap;
    }
  | {
      HostError: HostError;
    }
  | {
      ExecutionError: string;
    };
export type FunctionCallPermission = {
  /** @description Allowance is a balance limit to use by this access key to pay for function call gas and
   *     transaction fees. When this access key is used, both account balance and the allowance is
   *     decreased by the same value.
   *     `None` means unlimited allowance.
   *     NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
   *     access key should be created. */
  allowance?: string | null;
  /** @description A list of method names that can be used. The access key only allows transactions with the
   *     function call of one of the given method names.
   *     Empty list means any method name can be used. */
  methodNames: string[];
  /** @description The access key only allows transactions with the given receiver's account id. */
  receiverId: string;
};
export type GCConfig = {
  /**
   * Format: uint64
   * @description Maximum number of blocks to garbage collect at every garbage collection
   *     call.
   * @default 2
   */
  gcBlocksLimit: number;
  /**
   * Format: uint64
   * @description Maximum number of height to go through at each garbage collection step
   *     when cleaning forks during garbage collection.
   * @default 100
   */
  gcForkCleanStep: number;
  /**
   * Format: uint64
   * @description Number of epochs for which we keep store data.
   * @default 5
   */
  gcNumEpochsToKeep: number;
  /**
   * @description How often gc should be run
   * @default {
   *       "nanos": 500000000,
   *       "secs": 0
   *     }
   */
  gcStepPeriod: DurationAsStdSchemaProvider;
};
export type GasKeyView = {
  /** Format: uint128 */
  balance: number;
  /** Format: uint32 */
  numNonces: number;
  permission: AccessKeyPermissionView;
};
export type GenesisConfig = {
  /** @description Expected number of hidden validators per shard. */
  avgHiddenValidatorSeatsPerShard: number[];
  /**
   * Format: uint8
   * @description Threshold for kicking out block producers, between 0 and 100.
   */
  blockProducerKickoutThreshold: number;
  /** @description ID of the blockchain. This must be unique for every blockchain.
   *     If your testnet blockchains do not have unique chain IDs, you will have a bad time. */
  chainId: string;
  /**
   * Format: uint64
   * @description Limits the number of shard changes in chunk producer assignments,
   *     if algorithm is able to choose assignment with better balance of
   *     number of chunk producers for shards.
   * @default 5
   */
  chunkProducerAssignmentChangesLimit: number;
  /**
   * Format: uint8
   * @description Threshold for kicking out chunk producers, between 0 and 100.
   */
  chunkProducerKickoutThreshold: number;
  /**
   * Format: uint8
   * @description Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
   * @default 80
   */
  chunkValidatorOnlyKickoutThreshold: number;
  /** @description Enable dynamic re-sharding. */
  dynamicResharding: boolean;
  /**
   * Format: uint64
   * @description Epoch length counted in block heights.
   */
  epochLength: number;
  /** @description Fishermen stake threshold. */
  fishermenThreshold: string;
  /**
   * Format: uint64
   * @description Initial gas limit.
   */
  gasLimit: number;
  /** @description Gas price adjustment rate */
  gasPriceAdjustmentRate: number[];
  /**
   * Format: uint64
   * @description Height of genesis block.
   */
  genesisHeight: number;
  /**
   * Format: date-time
   * @description Official time of blockchain start.
   */
  genesisTime: string;
  maxGasPrice: string;
  /** @description Maximum inflation on the total supply every epoch. */
  maxInflationRate: number[];
  /**
   * Format: uint8
   * @description Max stake percentage of the validators we will kick out.
   * @default 100
   */
  maxKickoutStakePerc: number;
  /** @description Minimum gas price. It is also the initial gas price. */
  minGasPrice: string;
  /**
   * Format: uint64
   * @description The minimum stake required for staking is last seat price divided by this number.
   * @default 10
   */
  minimumStakeDivisor: number;
  /**
   * @description The lowest ratio s/s_total any block producer can have.
   *     See <https://github.com/near/NEPs/pull/167> for details
   * @default [
   *       1,
   *       6250
   *     ]
   */
  minimumStakeRatio: number[];
  /**
   * Format: uint64
   * @description The minimum number of validators each shard must have
   * @default 1
   */
  minimumValidatorsPerShard: number;
  /**
   * Format: uint64
   * @description Number of block producer seats at genesis.
   */
  numBlockProducerSeats: number;
  /** @description Defines number of shards and number of block producer seats per each shard at genesis.
   *     Note: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard
   *     Note: not used before as all block producers produce chunks for all shards */
  numBlockProducerSeatsPerShard: number[];
  /**
   * Format: uint64
   * @description Expected number of blocks per year
   */
  numBlocksPerYear: number;
  /**
   * Format: uint64
   * @description Deprecated.
   * @default 300
   */
  numChunkOnlyProducerSeats: number;
  /**
   * Format: uint64
   * @description Number of chunk producers.
   *     Don't mess it up with chunk-only producers feature which is deprecated.
   * @default 100
   */
  numChunkProducerSeats: number;
  /**
   * Format: uint64
   * @default 300
   */
  numChunkValidatorSeats: number;
  /**
   * @description Online maximum threshold above which validator gets full reward.
   * @default [
   *       99,
   *       100
   *     ]
   */
  onlineMaxThreshold: number[];
  /**
   * @description Online minimum threshold below which validator doesn't receive reward.
   * @default [
   *       9,
   *       10
   *     ]
   */
  onlineMinThreshold: number[];
  /** @description Protocol treasury rate */
  protocolRewardRate: number[];
  /** @description Protocol treasury account */
  protocolTreasuryAccount: AccountId;
  /**
   * @description Threshold of stake that needs to indicate that they ready for upgrade.
   * @default [
   *       4,
   *       5
   *     ]
   */
  protocolUpgradeStakeThreshold: number[];
  /**
   * Format: uint32
   * @description Protocol version that this genesis works with.
   */
  protocolVersion: number;
  /**
   * @description Layout information regarding how to split accounts to shards
   * @default {
   *       "V2": {
   *         "boundary_accounts": [],
   *         "id_to_index_map": {
   *           "0": 0
   *         },
   *         "index_to_id_map": {
   *           "0": 0
   *         },
   *         "shard_ids": [
   *           0
   *         ],
   *         "shards_parent_map": null,
   *         "shards_split_map": null,
   *         "version": 0
   *       }
   *     }
   */
  shardLayout: ShardLayout;
  /**
   * @description If true, shuffle the chunk producers across shards. In other words, if
   *     the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
   *     the set of chunk producers for shard `i`, if this flag were true, the
   *     shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.
   * @default false
   */
  shuffleShardAssignmentForChunkProducers: boolean;
  /**
   * Format: uint64
   * @description Number of target chunk validator mandates for each shard.
   * @default 68
   */
  targetValidatorMandatesPerShard: number;
  /** @description Total supply of tokens at genesis. */
  totalSupply: string;
  /**
   * Format: uint64
   * @description Number of blocks for which a given transaction is valid
   */
  transactionValidityPeriod: number;
  /**
   * @description This is only for test purposes. We hard code some configs for mainnet and testnet
   *     in AllEpochConfig, and we want to have a way to test that code path. This flag is for that.
   *     If set to true, the node will use the same config override path as mainnet and testnet.
   * @default false
   */
  useProductionConfig: boolean;
  /** @description List of initial validators. */
  validators: AccountInfo[];
};
export type GenesisConfigRequest = null;
export type GlobalContractDeployMode = 'CodeHash' | 'AccountId';
export type GlobalContractIdentifier =
  | {
      CodeHash: CryptoHash;
    }
  | {
      AccountId: AccountId;
    };
export type HostError =
  | 'BadUTF16'
  | 'BadUTF8'
  | 'GasExceeded'
  | 'GasLimitExceeded'
  | 'BalanceExceeded'
  | 'EmptyMethodName'
  | {
      GuestPanic: {
        panicMsg: string;
      };
    }
  | 'IntegerOverflow'
  | {
      InvalidPromiseIndex: {
        /** Format: uint64 */
        promiseIdx: number;
      };
    }
  | 'CannotAppendActionToJointPromise'
  | 'CannotReturnJointPromise'
  | {
      InvalidPromiseResultIndex: {
        /** Format: uint64 */
        resultIdx: number;
      };
    }
  | {
      InvalidRegisterId: {
        /** Format: uint64 */
        registerId: number;
      };
    }
  | {
      IteratorWasInvalidated: {
        /** Format: uint64 */
        iteratorIndex: number;
      };
    }
  | 'MemoryAccessViolation'
  | {
      InvalidReceiptIndex: {
        /** Format: uint64 */
        receiptIndex: number;
      };
    }
  | {
      InvalidIteratorIndex: {
        /** Format: uint64 */
        iteratorIndex: number;
      };
    }
  | 'InvalidAccountId'
  | 'InvalidMethodName'
  | 'InvalidPublicKey'
  | {
      ProhibitedInView: {
        methodName: string;
      };
    }
  | {
      NumberOfLogsExceeded: {
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      KeyLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      ValueLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      TotalLogLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      NumberPromisesExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        numberOfPromises: number;
      };
    }
  | {
      NumberInputDataDependenciesExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        numberOfInputDataDependencies: number;
      };
    }
  | {
      ReturnedValueLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      ContractSizeExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        size: number;
      };
    }
  | {
      Deprecated: {
        methodName: string;
      };
    }
  | {
      ECRecoverError: {
        msg: string;
      };
    }
  | {
      AltBn128InvalidInput: {
        msg: string;
      };
    }
  | {
      Ed25519VerifyInvalidInput: {
        msg: string;
      };
    };
export type InvalidAccessKeyError =
  | {
      AccessKeyNotFound: {
        accountId: AccountId;
        publicKey: PublicKey;
      };
    }
  | {
      ReceiverMismatch: {
        akReceiver: string;
        txReceiver: AccountId;
      };
    }
  | {
      MethodNameMismatch: {
        methodName: string;
      };
    }
  | 'RequiresFullAccess'
  | {
      NotEnoughAllowance: {
        accountId: AccountId;
        allowance: string;
        cost: string;
        publicKey: PublicKey;
      };
    }
  | 'DepositWithFunctionCall';
export type InvalidTxError =
  | {
      InvalidAccessKeyError: InvalidAccessKeyError;
    }
  | {
      InvalidSignerId: {
        signerId: string;
      };
    }
  | {
      SignerDoesNotExist: {
        signerId: AccountId;
      };
    }
  | {
      InvalidNonce: {
        /** Format: uint64 */
        akNonce: number;
        /** Format: uint64 */
        txNonce: number;
      };
    }
  | {
      NonceTooLarge: {
        /** Format: uint64 */
        txNonce: number;
        /** Format: uint64 */
        upperBound: number;
      };
    }
  | {
      InvalidReceiverId: {
        receiverId: string;
      };
    }
  | 'InvalidSignature'
  | {
      NotEnoughBalance: {
        balance: string;
        cost: string;
        signerId: AccountId;
      };
    }
  | {
      LackBalanceForState: {
        /** @description Required balance to cover the state. */
        amount: string;
        /** @description An account which doesn't have enough balance to cover storage. */
        signerId: AccountId;
      };
    }
  | 'CostOverflow'
  | 'InvalidChain'
  | 'Expired'
  | {
      ActionsValidation: ActionsValidationError;
    }
  | {
      TransactionSizeExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        size: number;
      };
    }
  | 'InvalidTransactionVersion'
  | {
      StorageError: StorageError;
    }
  | {
      ShardCongested: {
        /**
         * Format: double
         * @description A value between 0 (no congestion) and 1 (max congestion).
         */
        congestionLevel: number;
        /**
         * Format: uint32
         * @description The congested shard.
         */
        shardId: number;
      };
    }
  | {
      ShardStuck: {
        /**
         * Format: uint64
         * @description The number of blocks since the last included chunk of the shard.
         */
        missedChunks: number;
        /**
         * Format: uint32
         * @description The shard that fails making progress.
         */
        shardId: number;
      };
    };
export type JsonRpcRequest_for_EXPERIMENTAL_changes = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_changes';
  params: RpcStateChangesInBlockByTypeRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_changes_in_block = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_changes_in_block';
  params: RpcStateChangesInBlockRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_congestion_level = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_congestion_level';
  params: RpcCongestionLevelRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_genesis_config = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_genesis_config';
  params: GenesisConfigRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_light_client_block_proof = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_light_client_block_proof';
  params: RpcLightClientBlockProofRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_light_client_proof = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_light_client_proof';
  params: RpcLightClientExecutionProofRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_maintenance_windows = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_maintenance_windows';
  params: RpcMaintenanceWindowsRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_protocol_config = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_protocol_config';
  params: RpcProtocolConfigRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_receipt = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_receipt';
  params: RpcReceiptRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_split_storage_info = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_split_storage_info';
  params: RpcSplitStorageInfoRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_tx_status = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_tx_status';
  params: RpcTransactionStatusRequest;
};
export type JsonRpcRequest_for_EXPERIMENTAL_validators_ordered = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'EXPERIMENTAL_validators_ordered';
  params: RpcValidatorsOrderedRequest;
};
export type JsonRpcRequest_for_block = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'block';
  params: RpcBlockRequest;
};
export type JsonRpcRequest_for_broadcast_tx_async = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'broadcast_tx_async';
  params: RpcSendTransactionRequest;
};
export type JsonRpcRequest_for_broadcast_tx_commit = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'broadcast_tx_commit';
  params: RpcSendTransactionRequest;
};
export type JsonRpcRequest_for_changes = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'changes';
  params: RpcStateChangesInBlockByTypeRequest;
};
export type JsonRpcRequest_for_chunk = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'chunk';
  params: RpcChunkRequest;
};
export type JsonRpcRequest_for_client_config = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'client_config';
  params: RpcClientConfigRequest;
};
export type JsonRpcRequest_for_gas_price = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'gas_price';
  params: RpcGasPriceRequest;
};
export type JsonRpcRequest_for_health = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'health';
  params: RpcHealthRequest;
};
export type JsonRpcRequest_for_light_client_proof = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'light_client_proof';
  params: RpcLightClientExecutionProofRequest;
};
export type JsonRpcRequest_for_network_info = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'network_info';
  params: RpcNetworkInfoRequest;
};
export type JsonRpcRequest_for_next_light_client_block = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'next_light_client_block';
  params: RpcLightClientNextBlockRequest;
};
export type JsonRpcRequest_for_query = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'query';
  params: RpcQueryRequest;
};
export type JsonRpcRequest_for_send_tx = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'send_tx';
  params: RpcSendTransactionRequest;
};
export type JsonRpcRequest_for_status = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'status';
  params: RpcStatusRequest;
};
export type JsonRpcRequest_for_tx = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'tx';
  params: RpcTransactionStatusRequest;
};
export type JsonRpcRequest_for_validators = {
  id: string;
  jsonrpc: string;
  /** @enum {string} */
  method: 'validators';
  params: RpcValidatorRequest;
};
export type JsonRpcResponse_for_Array_of_Range_of_uint64_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: Range_of_uint64[];
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_Array_of_ValidatorStakeView_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: ValidatorStakeView[];
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_CryptoHash_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: CryptoHash;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_GenesisConfig_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: GenesisConfig;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_Nullable_RpcHealthResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcHealthResponse | null;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcBlockResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcBlockResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcChunkResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcChunkResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcClientConfigResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcClientConfigResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcCongestionLevelResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcCongestionLevelResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcGasPriceResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcGasPriceResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcLightClientBlockProofResponse_and_RpcError =
  {
    id: string;
    jsonrpc: string;
  } & (
    | {
        result: RpcLightClientBlockProofResponse;
      }
    | {
        error: RpcError;
      }
  );
export type JsonRpcResponse_for_RpcLightClientExecutionProofResponse_and_RpcError =
  {
    id: string;
    jsonrpc: string;
  } & (
    | {
        result: RpcLightClientExecutionProofResponse;
      }
    | {
        error: RpcError;
      }
  );
export type JsonRpcResponse_for_RpcLightClientNextBlockResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcLightClientNextBlockResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcNetworkInfoResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcNetworkInfoResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcProtocolConfigResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcProtocolConfigResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcQueryResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcQueryResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcReceiptResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcReceiptResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcSplitStorageInfoResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcSplitStorageInfoResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcStateChangesInBlockByTypeResponse_and_RpcError =
  {
    id: string;
    jsonrpc: string;
  } & (
    | {
        result: RpcStateChangesInBlockByTypeResponse;
      }
    | {
        error: RpcError;
      }
  );
export type JsonRpcResponse_for_RpcStateChangesInBlockResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcStateChangesInBlockResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcStatusResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcStatusResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcTransactionResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcTransactionResponse;
    }
  | {
      error: RpcError;
    }
);
export type JsonRpcResponse_for_RpcValidatorResponse_and_RpcError = {
  id: string;
  jsonrpc: string;
} & (
  | {
      result: RpcValidatorResponse;
    }
  | {
      error: RpcError;
    }
);
export type KnownProducerView = {
  accountId: AccountId;
  nextHops?: PublicKey[] | null;
  peerId: PublicKey;
};
export type LightClientBlockLiteView = {
  innerLite: BlockHeaderInnerLiteView;
  innerRestHash: CryptoHash;
  prevBlockHash: CryptoHash;
};
export type LimitConfig = {
  /**
   * @description Whether to enforce account_id well-formed-ness where it wasn't enforced
   *     historically.
   * @default 0
   */
  accountIdValidityRulesVersion: AccountIdValidityRulesVersion;
  /**
   * Format: uint32
   * @description The initial number of memory pages.
   *     NOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.
   */
  initialMemoryPages: number;
  /**
   * Format: uint64
   * @description Max number of actions per receipt.
   */
  maxActionsPerReceipt: number;
  /**
   * Format: uint64
   * @description Max length of arguments in a function call action.
   */
  maxArgumentsLength: number;
  /**
   * Format: uint64
   * @description Max contract size
   */
  maxContractSize: number;
  /**
   * Format: uint64
   * @description If present, stores max number of functions in one contract
   */
  maxFunctionsNumberPerContract?: number | null;
  /**
   * Format: uint64
   * @description Max amount of gas that can be used, excluding gas attached to promises.
   */
  maxGasBurnt: number;
  /**
   * Format: uint64
   * @description Max length of any method name (without terminating character).
   */
  maxLengthMethodName: number;
  /**
   * Format: uint64
   * @description Max length of returned data
   */
  maxLengthReturnedData: number;
  /**
   * Format: uint64
   * @description Max storage key size
   */
  maxLengthStorageKey: number;
  /**
   * Format: uint64
   * @description Max storage value size
   */
  maxLengthStorageValue: number;
  /**
   * Format: uint64
   * @description If present, stores max number of locals declared globally in one contract
   */
  maxLocalsPerContract?: number | null;
  /**
   * Format: uint32
   * @description What is the maximal memory pages amount is allowed to have for a contract.
   */
  maxMemoryPages: number;
  /**
   * Format: uint64
   * @description Max total length of all method names (including terminating character) for a function call
   *     permission access key.
   */
  maxNumberBytesMethodNames: number;
  /**
   * Format: uint64
   * @description Max number of input data dependencies
   */
  maxNumberInputDataDependencies: number;
  /**
   * Format: uint64
   * @description Maximum number of log entries.
   */
  maxNumberLogs: number;
  /**
   * Format: uint64
   * @description Maximum number of registers that can be used simultaneously.
   *
   *     Note that due to an implementation quirk [read: a bug] in VMLogic, if we
   *     have this number of registers, no subsequent writes to the registers
   *     will succeed even if they replace an existing register.
   */
  maxNumberRegisters: number;
  /**
   * Format: uint64
   * @description Max number of promises that a function call can create
   */
  maxPromisesPerFunctionCallAction: number;
  /**
   * Format: uint64
   * @description Max receipt size
   */
  maxReceiptSize: number;
  /**
   * Format: uint64
   * @description Maximum number of bytes that can be stored in a single register.
   */
  maxRegisterSize: number;
  /**
   * Format: uint32
   * @description How tall the stack is allowed to grow?
   *
   *     See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost
   *     is calculated.
   */
  maxStackHeight: number;
  /**
   * Format: uint64
   * @description Maximum total length in bytes of all log messages.
   */
  maxTotalLogLength: number;
  /**
   * Format: uint64
   * @description Max total prepaid gas for all function call actions per receipt.
   */
  maxTotalPrepaidGas: number;
  /**
   * Format: uint64
   * @description Max transaction size
   */
  maxTransactionSize: number;
  /**
   * Format: uint64
   * @description Maximum number of bytes for payload passed over a yield resume.
   */
  maxYieldPayloadSize: number;
  /**
   * Format: uint
   * @description Hard limit on the size of storage proof generated while executing a single receipt.
   */
  perReceiptStorageProofSizeLimit: number;
  /**
   * Format: uint64
   * @description Limit of memory used by registers.
   */
  registersMemoryLimit: number;
  /**
   * Format: uint64
   * @description Number of blocks after which a yielded promise times out.
   */
  yieldTimeoutLengthInBlocks: number;
};
export type LogSummaryStyle = 'plain' | 'colored';
export type MerklePathItem = {
  direction: Direction;
  hash: CryptoHash;
};
export type MethodResolveError =
  | 'MethodEmptyName'
  | 'MethodNotFound'
  | 'MethodInvalidSignature';
export type MissingTrieValue = {
  context: MissingTrieValueContext;
  hash: CryptoHash;
};
export type MissingTrieValueContext =
  | 'TrieIterator'
  | 'TriePrefetchingStorage'
  | 'TrieMemoryPartialStorage'
  | 'TrieStorage';
export type MutableConfigValue = string;
export type NetworkInfoView = {
  connectedPeers: PeerInfoView[];
  knownProducers: KnownProducerView[];
  /** Format: uint */
  numConnectedPeers: number;
  /** Format: uint32 */
  peerMaxCount: number;
  tier1AccountsData: AccountDataView[];
  tier1AccountsKeys: PublicKey[];
  tier1Connections: PeerInfoView[];
};
export type NextEpochValidatorInfo = {
  accountId: AccountId;
  publicKey: PublicKey;
  shards: ShardId[];
  stake: string;
};
export type NonDelegateAction = Action;
export type PeerId = PublicKey;
export type PeerInfoView = {
  accountId?: AccountId | null;
  addr: string;
  archival: boolean;
  blockHash?: CryptoHash | null;
  /** Format: uint64 */
  connectionEstablishedTimeMillis: number;
  /** Format: uint64 */
  height?: number | null;
  isHighestBlockInvalid: boolean;
  isOutboundPeer: boolean;
  /** Format: uint64 */
  lastTimePeerRequestedMillis: number;
  /** Format: uint64 */
  lastTimeReceivedMessageMillis: number;
  /**
   * Format: uint64
   * @description Connection nonce.
   */
  nonce: number;
  peerId: PublicKey;
  /** Format: uint64 */
  receivedBytesPerSec: number;
  /** Format: uint64 */
  sentBytesPerSec: number;
  trackedShards: ShardId[];
};
export type PrepareError =
  | 'Serialization'
  | 'Deserialization'
  | 'InternalMemoryDeclared'
  | 'GasInstrumentation'
  | 'StackHeightInstrumentation'
  | 'Instantiate'
  | 'Memory'
  | 'TooManyFunctions'
  | 'TooManyLocals';
export type PublicKey = string;
export type Range_of_uint64 = {
  /** Format: uint64 */
  end: number;
  /** Format: uint64 */
  start: number;
};
export type ReceiptEnumView =
  | {
      Action: {
        actions: ActionView[];
        gasPrice: string;
        inputDataIds: CryptoHash[];
        /** @default false */
        isPromiseYield: boolean;
        outputDataReceivers: DataReceiverView[];
        signerId: AccountId;
        signerPublicKey: PublicKey;
      };
    }
  | {
      Data: {
        /** @default null */
        data: string | null;
        dataId: CryptoHash;
        /** @default false */
        isPromiseResume: boolean;
      };
    }
  | {
      GlobalContractDistribution: {
        alreadyDeliveredShards: ShardId[];
        code: string;
        id: GlobalContractIdentifier;
        targetShard: ShardId;
      };
    };
export type ReceiptValidationError =
  | {
      InvalidPredecessorId: {
        accountId: string;
      };
    }
  | {
      InvalidReceiverId: {
        accountId: string;
      };
    }
  | {
      InvalidSignerId: {
        accountId: string;
      };
    }
  | {
      InvalidDataReceiverId: {
        accountId: string;
      };
    }
  | {
      ReturnedValueLengthExceeded: {
        /** Format: uint64 */
        length: number;
        /** Format: uint64 */
        limit: number;
      };
    }
  | {
      NumberInputDataDependenciesExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        numberOfInputDataDependencies: number;
      };
    }
  | {
      ActionsValidation: ActionsValidationError;
    }
  | {
      ReceiptSizeExceeded: {
        /** Format: uint64 */
        limit: number;
        /** Format: uint64 */
        size: number;
      };
    };
export type ReceiptView = {
  predecessorId: AccountId;
  /**
   * Format: uint64
   * @default 0
   */
  priority: number;
  receipt: ReceiptEnumView;
  receiptId: CryptoHash;
  receiverId: AccountId;
};
export type RpcBlockRequest =
  | {
      blockId: BlockId;
    }
  | {
      finality: Finality;
    }
  | {
      syncCheckpoint: SyncCheckpoint;
    };
export type RpcBlockResponse = {
  /** @description The AccountId of the author of the Block */
  author: AccountId;
  chunks: ChunkHeaderView[];
  header: BlockHeaderView;
};
export type RpcChunkRequest =
  | {
      blockId: BlockId;
      shardId: ShardId;
    }
  | {
      chunkId: CryptoHash;
    };
export type RpcChunkResponse = {
  author: AccountId;
  header: ChunkHeaderView;
  receipts: ReceiptView[];
  transactions: SignedTransactionView[];
};
export type RpcClientConfigRequest = null;
export type RpcClientConfigResponse = {
  /** @description Not clear old data, set `true` for archive nodes. */
  archive: boolean;
  /**
   * Format: uint64
   * @description Horizon at which instead of fetching block, fetch full state.
   */
  blockFetchHorizon: number;
  /**
   * Format: uint64
   * @description Behind this horizon header fetch kicks in.
   */
  blockHeaderFetchHorizon: number;
  /** @description Duration to check for producing / skipping block. */
  blockProductionTrackingDelay: number[];
  /** @description Time between check to perform catchup. */
  catchupStepPeriod: number[];
  /** @description Chain id for status. */
  chainId: string;
  /** @description Optional config for the Chunk Distribution Network feature.
   *     If set to `None` then this node does not participate in the Chunk Distribution Network.
   *     Nodes not participating will still function fine, but possibly with higher
   *     latency due to the need of requesting chunks over the peer-to-peer network. */
  chunkDistributionNetwork?: ChunkDistributionNetworkConfig | null;
  /** @description Time between checking to re-request chunks. */
  chunkRequestRetryPeriod: number[];
  /** @description Multiplier for the wait time for all chunks to be received. */
  chunkWaitMult: number[];
  /**
   * Format: uint
   * @description Number of threads to execute background migration work in client.
   */
  clientBackgroundMigrationThreads: number;
  /** @description Time between running doomslug timer. */
  doomslugStepPeriod: number[];
  enableMultilineLogging: boolean;
  /** @description Re-export storage layer statistics as prometheus metrics. */
  enableStatisticsExport: boolean;
  /**
   * Format: uint64
   * @description Epoch length.
   */
  epochLength: number;
  /** @description Options for epoch sync. */
  epochSync: EpochSyncConfig;
  /** @description Graceful shutdown at expected block height. */
  expectedShutdown: MutableConfigValue;
  /** @description Garbage collection configuration. */
  gc: GCConfig;
  /**
   * Format: uint64
   * @description Expected increase of header head height per second during header sync
   */
  headerSyncExpectedHeightPerSecond: number;
  /** @description How much time to wait after initial header sync */
  headerSyncInitialTimeout: number[];
  /** @description How much time to wait after some progress is made in header sync */
  headerSyncProgressTimeout: number[];
  /** @description How much time to wait before banning a peer in header sync if sync is too slow */
  headerSyncStallBanTimeout: number[];
  /** @description Period between logging summary information. */
  logSummaryPeriod: number[];
  /** @description Enable coloring of the logs */
  logSummaryStyle: LogSummaryStyle;
  /** @description Maximum wait for approvals before producing block. */
  maxBlockProductionDelay: number[];
  /** @description Maximum duration before skipping given height. */
  maxBlockWaitDelay: number[];
  /**
   * Format: uint64
   * @description Max burnt gas per view method.  If present, overrides value stored in
   *     genesis file.  The value only affects the RPCs without influencing the
   *     protocol thus changing it per-node doesnt affect the blockchain.
   */
  maxGasBurntView?: number | null;
  /** @description Minimum duration before producing block. */
  minBlockProductionDelay: number[];
  /**
   * Format: uint
   * @description Minimum number of peers to start syncing.
   */
  minNumPeers: number;
  /**
   * Format: uint64
   * @description Number of block producer seats
   */
  numBlockProducerSeats: number;
  /**
   * Format: uint64
   * @description Maximum size of state witnesses in the OrphanStateWitnessPool.
   *
   *     We keep only orphan witnesses which are smaller than this size.
   *     This limits the maximum memory usage of OrphanStateWitnessPool.
   */
  orphanStateWitnessMaxSize: number;
  /**
   * Format: uint
   * @description OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed
   *     because the previous block isn't available. The witnesses wait in the pool until the
   *     required block appears. This variable controls how many witnesses can be stored in the pool.
   */
  orphanStateWitnessPoolSize: number;
  /** @description Limit the time of adding transactions to a chunk.
   *     A node produces a chunk by adding transactions from the transaction pool until
   *     some limit is reached. This time limit ensures that adding transactions won't take
   *     longer than the specified duration, which helps to produce the chunk quickly. */
  produceChunkAddTransactionsTimeLimit: string;
  /** @description Produce empty blocks, use `false` for testing. */
  produceEmptyBlocks: boolean;
  reshardingConfig: MutableConfigValue;
  /** @description Listening rpc port for status. */
  rpcAddr?: string | null;
  /** @description Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.
   *     Saving invalid witnesses is useful for analysis and debugging.
   *     This option can cause extra load on the database and is not recommended for production use. */
  saveInvalidWitnesses: boolean;
  /** @description Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.
   *     Saving the latest witnesses is useful for analysis and debugging.
   *     This option can cause extra load on the database and is not recommended for production use. */
  saveLatestWitnesses: boolean;
  /** @description save_trie_changes should be set to true iff
   *     - archive if false - non-archival nodes need trie changes to perform garbage collection
   *     - archive is true, cold_store is configured and migration to split_storage is finished - node
   *     working in split storage mode needs trie changes in order to do garbage collection on hot. */
  saveTrieChanges: boolean;
  /** @description Whether to persist transaction outcomes to disk or not. */
  saveTxOutcomes: boolean;
  /** @description Skip waiting for sync (for testing or single node testnet). */
  skipSyncWait: boolean;
  /** @description Options for syncing state. */
  stateSync: StateSyncConfig;
  /** @description Whether to use the State Sync mechanism.
   *     If disabled, the node will do Block Sync instead of State Sync. */
  stateSyncEnabled: boolean;
  /** @description Additional waiting period after a failed request to external storage */
  stateSyncExternalBackoff: number[];
  /** @description How long to wait for a response from centralized state sync */
  stateSyncExternalTimeout: number[];
  /** @description How long to wait for a response from p2p state sync */
  stateSyncP2pTimeout: number[];
  /** @description How long to wait after a failed state sync request */
  stateSyncRetryBackoff: number[];
  /** @description How often to check that we are not out of sync. */
  syncCheckPeriod: number[];
  /**
   * Format: uint64
   * @description Sync height threshold: below this difference in height don't start syncing.
   */
  syncHeightThreshold: number;
  /**
   * Format: uint
   * @description Maximum number of block requests to send to peers to sync
   */
  syncMaxBlockRequests: number;
  /** @description While syncing, how long to check for each step. */
  syncStepPeriod: number[];
  trackedShardsConfig: TrackedShardsConfig;
  /**
   * Format: uint64
   * @description Limit of the size of per-shard transaction pool measured in bytes. If not set, the size
   *     will be unbounded.
   */
  transactionPoolSizeLimit?: number | null;
  /** Format: uint */
  transactionRequestHandlerThreads: number;
  /**
   * Format: uint64
   * @description Upper bound of the byte size of contract state that is still viewable. None is no limit
   */
  trieViewerStateSizeLimit?: number | null;
  /** @description Time to persist Accounts Id in the router without removing them. */
  ttlAccountIdRouter: number[];
  /**
   * Format: uint64
   * @description If the node is not a chunk producer within that many blocks, then route
   *     to upcoming chunk producers.
   */
  txRoutingHeightHorizon: number;
  /** @description Version of the binary. */
  version: Version;
  /**
   * Format: uint
   * @description Maximum number of state requests served per `view_client_throttle_period`
   */
  viewClientNumStateRequestsPerThrottlePeriod: number;
  /**
   * Format: uint
   * @description Number of threads for ViewClientActor pool.
   */
  viewClientThreads: number;
  /** @description Throttling window for state requests (headers and parts). */
  viewClientThrottlePeriod: number[];
};
export type RpcCongestionLevelRequest =
  | {
      blockId: BlockId;
      shardId: ShardId;
    }
  | {
      chunkId: CryptoHash;
    };
export type RpcCongestionLevelResponse = {
  /** Format: double */
  congestionLevel: number;
};
export type RpcError = {
  cause?: unknown;
  /**
   * Format: int64
   * @description Deprecated please use the `error_struct` instead
   */
  code: number;
  /** @description Deprecated please use the `error_struct` instead */
  data?: unknown;
  /** @description Deprecated please use the `error_struct` instead */
  message: string;
  name?: unknown;
} & (
  | {
      cause?: RpcRequestValidationErrorKind;
      /** @enum {string} */
      name: 'REQUEST_VALIDATION_ERROR';
    }
  | {
      cause?: unknown;
      /** @enum {string} */
      name: 'HANDLER_ERROR';
    }
  | {
      cause?: unknown;
      /** @enum {string} */
      name: 'INTERNAL_ERROR';
    }
);
export type RpcGasPriceRequest = {
  blockId?: BlockId | null;
};
export type RpcGasPriceResponse = {
  gasPrice: string;
};
export type RpcHealthRequest = null;
export type RpcHealthResponse = null;
export type RpcKnownProducer = {
  accountId: AccountId;
  addr?: string | null;
  peerId: PeerId;
};
export type RpcLightClientBlockProofRequest = {
  blockHash: CryptoHash;
  lightClientHead: CryptoHash;
};
export type RpcLightClientBlockProofResponse = {
  blockHeaderLite: LightClientBlockLiteView;
  blockProof: MerklePathItem[];
};
export type RpcLightClientExecutionProofRequest = {
  lightClientHead: CryptoHash;
} & (
  | {
      senderId: AccountId;
      transactionHash: CryptoHash;
      /** @enum {string} */
      type: 'transaction';
    }
  | {
      receiptId: CryptoHash;
      receiverId: AccountId;
      /** @enum {string} */
      type: 'receipt';
    }
);
export type RpcLightClientExecutionProofResponse = {
  blockHeaderLite: LightClientBlockLiteView;
  blockProof: MerklePathItem[];
  outcomeProof: ExecutionOutcomeWithIdView;
  outcomeRootProof: MerklePathItem[];
};
export type RpcLightClientNextBlockRequest = {
  lastBlockHash: CryptoHash;
};
export type RpcLightClientNextBlockResponse = {
  approvalsAfterNext?: (Signature | null)[];
  /** @description Inner part of the block header that gets hashed, split into two parts, one that is sent
   *        to light clients, and the rest */
  innerLite?: BlockHeaderInnerLiteView;
  innerRestHash?: CryptoHash;
  nextBlockInnerHash?: CryptoHash;
  nextBps?: ValidatorStakeView[] | null;
  prevBlockHash?: CryptoHash;
};
export type RpcMaintenanceWindowsRequest = {
  accountId: AccountId;
};
export type RpcNetworkInfoRequest = null;
export type RpcNetworkInfoResponse = {
  activePeers: RpcPeerInfo[];
  /** @description Accounts of known block and chunk producers from routing table. */
  knownProducers: RpcKnownProducer[];
  /** Format: uint */
  numActivePeers: number;
  /** Format: uint32 */
  peerMaxCount: number;
  /** Format: uint64 */
  receivedBytesPerSec: number;
  /** Format: uint64 */
  sentBytesPerSec: number;
};
export type RpcPeerInfo = {
  accountId?: AccountId | null;
  addr?: string | null;
  id: PeerId;
};
export type RpcProtocolConfigRequest =
  | {
      blockId: BlockId;
    }
  | {
      finality: Finality;
    }
  | {
      syncCheckpoint: SyncCheckpoint;
    };
export type RpcProtocolConfigResponse = {
  /** @description Expected number of hidden validators per shard. */
  avgHiddenValidatorSeatsPerShard: number[];
  /**
   * Format: uint8
   * @description Threshold for kicking out block producers, between 0 and 100.
   */
  blockProducerKickoutThreshold: number;
  /** @description ID of the blockchain. This must be unique for every blockchain.
   *     If your testnet blockchains do not have unique chain IDs, you will have a bad time. */
  chainId: string;
  /**
   * Format: uint8
   * @description Threshold for kicking out chunk producers, between 0 and 100.
   */
  chunkProducerKickoutThreshold: number;
  /**
   * Format: uint8
   * @description Threshold for kicking out nodes which are only chunk validators, between 0 and 100.
   */
  chunkValidatorOnlyKickoutThreshold: number;
  /** @description Enable dynamic re-sharding. */
  dynamicResharding: boolean;
  /**
   * Format: uint64
   * @description Epoch length counted in block heights.
   */
  epochLength: number;
  /** @description Fishermen stake threshold. */
  fishermenThreshold: string;
  /**
   * Format: uint64
   * @description Initial gas limit.
   */
  gasLimit: number;
  /** @description Gas price adjustment rate */
  gasPriceAdjustmentRate: number[];
  /**
   * Format: uint64
   * @description Height of genesis block.
   */
  genesisHeight: number;
  /**
   * Format: date-time
   * @description Official time of blockchain start.
   */
  genesisTime: string;
  /** @description Maximum gas price. */
  maxGasPrice: string;
  /** @description Maximum inflation on the total supply every epoch. */
  maxInflationRate: number[];
  /**
   * Format: uint8
   * @description Max stake percentage of the validators we will kick out.
   */
  maxKickoutStakePerc: number;
  /** @description Minimum gas price. It is also the initial gas price. */
  minGasPrice: string;
  /**
   * Format: uint64
   * @description The minimum stake required for staking is last seat price divided by this number.
   */
  minimumStakeDivisor: number;
  /** @description The lowest ratio s/s_total any block producer can have.
   *     See <https://github.com/near/NEPs/pull/167> for details */
  minimumStakeRatio: number[];
  /**
   * Format: uint64
   * @description The minimum number of validators each shard must have
   */
  minimumValidatorsPerShard: number;
  /**
   * Format: uint64
   * @description Number of block producer seats at genesis.
   */
  numBlockProducerSeats: number;
  /** @description Defines number of shards and number of block producer seats per each shard at genesis. */
  numBlockProducerSeatsPerShard: number[];
  /**
   * Format: uint64
   * @description Expected number of blocks per year
   */
  numBlocksPerYear: number;
  /** @description Online maximum threshold above which validator gets full reward. */
  onlineMaxThreshold: number[];
  /** @description Online minimum threshold below which validator doesn't receive reward. */
  onlineMinThreshold: number[];
  /** @description Protocol treasury rate */
  protocolRewardRate: number[];
  /** @description Protocol treasury account */
  protocolTreasuryAccount: AccountId;
  /** @description Threshold of stake that needs to indicate that they ready for upgrade. */
  protocolUpgradeStakeThreshold: number[];
  /**
   * Format: uint32
   * @description Current Protocol Version
   */
  protocolVersion: number;
  /** @description Runtime configuration (mostly economics constants). */
  runtimeConfig: RuntimeConfigView;
  /** @description Layout information regarding how to split accounts to shards */
  shardLayout: ShardLayout;
  /** @description If true, shuffle the chunk producers across shards. In other words, if
   *     the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents
   *     the set of chunk producers for shard `i`, if this flag were true, the
   *     shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`. */
  shuffleShardAssignmentForChunkProducers: boolean;
  /**
   * Format: uint64
   * @description Number of target chunk validator mandates for each shard.
   */
  targetValidatorMandatesPerShard: number;
  /**
   * Format: uint64
   * @description Number of blocks for which a given transaction is valid
   */
  transactionValidityPeriod: number;
};
export type RpcQueryRequest =
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_account';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_code';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      includeProof?: boolean;
      prefixBase64: StoreKey;
      /** @enum {string} */
      requestType: 'view_state';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      publicKey: PublicKey;
      /** @enum {string} */
      requestType: 'view_access_key';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_access_key_list';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      argsBase64: FunctionArgs;
      methodName: string;
      /** @enum {string} */
      requestType: 'call_function';
    })
  | ({
      blockId: BlockId;
    } & {
      codeHash: CryptoHash;
      /** @enum {string} */
      requestType: 'view_global_contract_code';
    })
  | ({
      blockId: BlockId;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_global_contract_code_by_account_id';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_account';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_code';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      includeProof?: boolean;
      prefixBase64: StoreKey;
      /** @enum {string} */
      requestType: 'view_state';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      publicKey: PublicKey;
      /** @enum {string} */
      requestType: 'view_access_key';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_access_key_list';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      argsBase64: FunctionArgs;
      methodName: string;
      /** @enum {string} */
      requestType: 'call_function';
    })
  | ({
      finality: Finality;
    } & {
      codeHash: CryptoHash;
      /** @enum {string} */
      requestType: 'view_global_contract_code';
    })
  | ({
      finality: Finality;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_global_contract_code_by_account_id';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_account';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_code';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      includeProof?: boolean;
      prefixBase64: StoreKey;
      /** @enum {string} */
      requestType: 'view_state';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      publicKey: PublicKey;
      /** @enum {string} */
      requestType: 'view_access_key';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_access_key_list';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      argsBase64: FunctionArgs;
      methodName: string;
      /** @enum {string} */
      requestType: 'call_function';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      codeHash: CryptoHash;
      /** @enum {string} */
      requestType: 'view_global_contract_code';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountId: AccountId;
      /** @enum {string} */
      requestType: 'view_global_contract_code_by_account_id';
    });
export type RpcQueryResponse =
  | {
      blockHash: CryptoHash;
      /** Format: uint64 */
      blockHeight: number;
    }
  | AccountView
  | ContractCodeView
  | ViewStateResult
  | CallResult
  | AccessKeyView
  | AccessKeyList;
export type RpcReceiptRequest = {
  receiptId: CryptoHash;
};
export type RpcReceiptResponse = {
  predecessorId: AccountId;
  /**
   * Format: uint64
   * @default 0
   */
  priority: number;
  receipt: ReceiptEnumView;
  receiptId: CryptoHash;
  receiverId: AccountId;
};
export type RpcRequestValidationErrorKind =
  | {
      info: {
        methodName: string;
      };
      /** @enum {string} */
      name: 'METHOD_NOT_FOUND';
    }
  | {
      info: {
        errorMessage: string;
      };
      /** @enum {string} */
      name: 'PARSE_ERROR';
    };
export type RpcSendTransactionRequest = {
  signedTxBase64: SignedTransaction;
  /** @default EXECUTED_OPTIMISTIC */
  waitUntil: TxExecutionStatus;
};
export type RpcSplitStorageInfoRequest = {};
export type RpcSplitStorageInfoResponse = {
  /** Format: uint64 */
  coldHeadHeight?: number | null;
  /** Format: uint64 */
  finalHeadHeight?: number | null;
  /** Format: uint64 */
  headHeight?: number | null;
  hotDbKind?: string | null;
};
export type RpcStateChangesInBlockByTypeRequest =
  | ({
      blockId: BlockId;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'account_changes';
    })
  | ({
      blockId: BlockId;
    } & {
      /** @enum {string} */
      changesType: 'single_access_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      blockId: BlockId;
    } & {
      /** @enum {string} */
      changesType: 'single_gas_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      blockId: BlockId;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_access_key_changes';
    })
  | ({
      blockId: BlockId;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_gas_key_changes';
    })
  | ({
      blockId: BlockId;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'contract_code_changes';
    })
  | ({
      blockId: BlockId;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'data_changes';
      keyPrefixBase64: StoreKey;
    })
  | ({
      finality: Finality;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'account_changes';
    })
  | ({
      finality: Finality;
    } & {
      /** @enum {string} */
      changesType: 'single_access_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      finality: Finality;
    } & {
      /** @enum {string} */
      changesType: 'single_gas_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      finality: Finality;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_access_key_changes';
    })
  | ({
      finality: Finality;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_gas_key_changes';
    })
  | ({
      finality: Finality;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'contract_code_changes';
    })
  | ({
      finality: Finality;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'data_changes';
      keyPrefixBase64: StoreKey;
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'account_changes';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      /** @enum {string} */
      changesType: 'single_access_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      /** @enum {string} */
      changesType: 'single_gas_key_changes';
      keys: AccountWithPublicKey[];
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_access_key_changes';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'all_gas_key_changes';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'contract_code_changes';
    })
  | ({
      syncCheckpoint: SyncCheckpoint;
    } & {
      accountIds: AccountId[];
      /** @enum {string} */
      changesType: 'data_changes';
      keyPrefixBase64: StoreKey;
    });
export type RpcStateChangesInBlockByTypeResponse = {
  blockHash: CryptoHash;
  changes: StateChangeKindView[];
};
export type RpcStateChangesInBlockRequest =
  | {
      blockId: BlockId;
    }
  | {
      finality: Finality;
    }
  | {
      syncCheckpoint: SyncCheckpoint;
    };
export type RpcStateChangesInBlockResponse = {
  blockHash: CryptoHash;
  changes: StateChangeWithCauseView[];
};
export type RpcStatusRequest = null;
export type RpcStatusResponse = {
  /** @description Unique chain id. */
  chainId: string;
  /** @description Information about last blocks, network, epoch and chain & chunk info. */
  detailedDebugStatus?: DetailedDebugStatus | null;
  /** @description Genesis hash of the chain. */
  genesisHash: CryptoHash;
  /**
   * Format: uint32
   * @description Latest protocol version that this client supports.
   */
  latestProtocolVersion: number;
  /** @description Deprecated; same as `validator_public_key` which you should use instead. */
  nodeKey?: PublicKey | null;
  /** @description Public key of the node. */
  nodePublicKey: PublicKey;
  /**
   * Format: uint32
   * @description Currently active protocol version.
   */
  protocolVersion: number;
  /** @description Address for RPC server.  None if node doesn't have RPC endpoint enabled. */
  rpcAddr?: string | null;
  /** @description Sync status of the node. */
  syncInfo: StatusSyncInfo;
  /**
   * Format: int64
   * @description Uptime of the node.
   */
  uptimeSec: number;
  /** @description Validator id of the node */
  validatorAccountId?: AccountId | null;
  /** @description Public key of the validator. */
  validatorPublicKey?: PublicKey | null;
  /** @description Current epoch validators. */
  validators: ValidatorInfo[];
  /** @description Binary version. */
  version: Version;
};
export type RpcTransactionResponse =
  | {
      finalExecutionStatus: TxExecutionStatus;
    }
  | FinalExecutionOutcomeWithReceiptView
  | FinalExecutionOutcomeView;
export type RpcTransactionStatusRequest =
  | {
      /** @default EXECUTED_OPTIMISTIC */
      waitUntil: TxExecutionStatus;
    }
  | {
      signedTxBase64: SignedTransaction;
    }
  | {
      senderAccountId: AccountId;
      txHash: CryptoHash;
    };
export type RpcValidatorRequest =
  | 'latest'
  | {
      epochId: EpochId;
    }
  | {
      blockId: BlockId;
    };
export type RpcValidatorResponse = {
  /** @description Fishermen for the current epoch */
  currentFishermen: ValidatorStakeView[];
  /** @description Proposals in the current epoch */
  currentProposals: ValidatorStakeView[];
  /** @description Validators for the current epoch */
  currentValidators: CurrentEpochValidatorInfo[];
  /**
   * Format: uint64
   * @description Epoch height
   */
  epochHeight: number;
  /**
   * Format: uint64
   * @description Epoch start block height
   */
  epochStartHeight: number;
  /** @description Fishermen for the next epoch */
  nextFishermen: ValidatorStakeView[];
  /** @description Validators for the next epoch */
  nextValidators: NextEpochValidatorInfo[];
  /** @description Kickout in the previous epoch */
  prevEpochKickout: ValidatorKickoutView[];
};
export type RpcValidatorsOrderedRequest = {
  blockId?: BlockId | null;
};
export type RuntimeConfigView = {
  /** @description Config that defines rules for account creation. */
  accountCreationConfig: AccountCreationConfigView;
  /** @description The configuration for congestion control. */
  congestionControlConfig: CongestionControlConfigView;
  /** @description Amount of yN per byte required to have on the account.  See
   *     <https://nomicon.io/Economics/Economic#state-stake> for details. */
  storageAmountPerByte: string;
  /** @description Costs of different actions that need to be performed when sending and
   *     processing transaction and receipts. */
  transactionCosts: RuntimeFeesConfigView;
  /** @description Config of wasm operations. */
  wasmConfig: VMConfigView;
  /** @description Configuration specific to ChunkStateWitness. */
  witnessConfig: WitnessConfigView;
};
export type RuntimeFeesConfigView = {
  /** @description Describes the cost of creating a certain action, `Action`. Includes all variants. */
  actionCreationConfig: ActionCreationConfigView;
  /** @description Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost
   *     of actions.
   *     - `send` cost is burned when a receipt is created using `promise_create` or
   *         `promise_batch_create`
   *     - `exec` cost is burned when the receipt is being executed. */
  actionReceiptCreationConfig: Fee;
  /** @description Fraction of the burnt gas to reward to the contract account for execution. */
  burntGasReward: number[];
  /** @description Describes the cost of creating a data receipt, `DataReceipt`. */
  dataReceiptCreationConfig: DataReceiptCreationConfigView;
  /** @description Pessimistic gas price inflation ratio. */
  pessimisticGasPriceInflationRatio: number[];
  /** @description Describes fees for storage. */
  storageUsageConfig: StorageUsageConfigView;
};
export type ShardId = number;
export type ShardLayout =
  | {
      V0: ShardLayoutV0;
    }
  | {
      V1: ShardLayoutV1;
    }
  | {
      V2: ShardLayoutV2;
    };
export type ShardLayoutV0 = {
  /**
   * Format: uint64
   * @description Map accounts evenly across all shards
   */
  numShards: number;
  /**
   * Format: uint32
   * @description Version of the shard layout, this is useful for uniquely identify the shard layout
   */
  version: number;
};
export type ShardLayoutV1 = {
  /** @description The boundary accounts are the accounts on boundaries between shards.
   *     Each shard contains a range of accounts from one boundary account to
   *     another - or the smallest or largest account possible. The total
   *     number of shards is equal to the number of boundary accounts plus 1. */
  boundaryAccounts: AccountId[];
  /** @description Maps shards from the last shard layout to shards that it splits to in this shard layout,
   *     Useful for constructing states for the shards.
   *     None for the genesis shard layout */
  shardsSplitMap?: ShardId[][] | null;
  /** @description Maps shard in this shard layout to their parent shard
   *     Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap */
  toParentShardMap?: ShardId[] | null;
  /**
   * Format: uint32
   * @description Version of the shard layout, this is useful for uniquely identify the shard layout
   */
  version: number;
};
export type ShardLayoutV2 = {
  boundaryAccounts: AccountId[];
  idToIndexMap: {
    [key: string]: number;
  };
  indexToIdMap: {
    [key: string]: ShardId;
  };
  shardIds: ShardId[];
  shardsParentMap?: {
    [key: string]: ShardId;
  } | null;
  shardsSplitMap?: {
    [key: string]: ShardId[];
  } | null;
  /** Format: uint32 */
  version: number;
};
export type ShardUId = {
  /** Format: uint32 */
  shardId: number;
  /** Format: uint32 */
  version: number;
};
export type Signature = string;
export type SignedDelegateAction = {
  delegateAction: DelegateAction;
  signature: Signature;
};
export type SignedTransaction = string;
export type SignedTransactionView = {
  actions: ActionView[];
  hash: CryptoHash;
  /** Format: uint64 */
  nonce: number;
  /**
   * Format: uint64
   * @default 0
   */
  priorityFee: number;
  publicKey: PublicKey;
  receiverId: AccountId;
  signature: Signature;
  signerId: AccountId;
};
export type SlashedValidator = {
  accountId: AccountId;
  isDoubleSign: boolean;
};
export type StakeAction = {
  /** @description Validator key which will be used to sign transactions on behalf of signer_id */
  publicKey: PublicKey;
  /** @description Amount of tokens to stake. */
  stake: string;
};
export type StateChangeCauseView =
  | {
      /** @enum {string} */
      type: 'not_writable_to_disk';
    }
  | {
      /** @enum {string} */
      type: 'initial_state';
    }
  | {
      txHash: CryptoHash;
      /** @enum {string} */
      type: 'transaction_processing';
    }
  | {
      receiptHash: CryptoHash;
      /** @enum {string} */
      type: 'action_receipt_processing_started';
    }
  | {
      receiptHash: CryptoHash;
      /** @enum {string} */
      type: 'action_receipt_gas_reward';
    }
  | {
      receiptHash: CryptoHash;
      /** @enum {string} */
      type: 'receipt_processing';
    }
  | {
      receiptHash: CryptoHash;
      /** @enum {string} */
      type: 'postponed_receipt';
    }
  | {
      /** @enum {string} */
      type: 'updated_delayed_receipts';
    }
  | {
      /** @enum {string} */
      type: 'validator_accounts_update';
    }
  | {
      /** @enum {string} */
      type: 'migration';
    }
  | {
      /** @enum {string} */
      type: 'bandwidth_scheduler_state_update';
    };
export type StateChangeKindView =
  | {
      accountId: AccountId;
      /** @enum {string} */
      type: 'account_touched';
    }
  | {
      accountId: AccountId;
      /** @enum {string} */
      type: 'access_key_touched';
    }
  | {
      accountId: AccountId;
      /** @enum {string} */
      type: 'data_touched';
    }
  | {
      accountId: AccountId;
      /** @enum {string} */
      type: 'contract_code_touched';
    };
export type StateChangeWithCauseView = {
  cause: StateChangeCauseView;
} & (
  | {
      /** @description A view of the account */
      change: {
        accountId: AccountId;
        amount: string;
        codeHash: CryptoHash;
        globalContractAccountId?: AccountId | null;
        globalContractHash?: CryptoHash | null;
        locked: string;
        /**
         * Format: uint64
         * @description TODO(2271): deprecated.
         * @default 0
         */
        storagePaidAt: number;
        /** Format: uint64 */
        storageUsage: number;
      };
      /** @enum {string} */
      type: 'account_update';
    }
  | {
      change: {
        accountId: AccountId;
      };
      /** @enum {string} */
      type: 'account_deletion';
    }
  | {
      change: {
        accessKey: AccessKeyView;
        accountId: AccountId;
        publicKey: PublicKey;
      };
      /** @enum {string} */
      type: 'access_key_update';
    }
  | {
      change: {
        accountId: AccountId;
        publicKey: PublicKey;
      };
      /** @enum {string} */
      type: 'access_key_deletion';
    }
  | {
      change: {
        accountId: AccountId;
        gasKey: GasKeyView;
        publicKey: PublicKey;
      };
      /** @enum {string} */
      type: 'gas_key_update';
    }
  | {
      change: {
        accountId: AccountId;
        /** Format: uint32 */
        index: number;
        /** Format: uint64 */
        nonce: number;
        publicKey: PublicKey;
      };
      /** @enum {string} */
      type: 'gas_key_nonce_update';
    }
  | {
      change: {
        accountId: AccountId;
        publicKey: PublicKey;
      };
      /** @enum {string} */
      type: 'gas_key_deletion';
    }
  | {
      change: {
        accountId: AccountId;
        keyBase64: StoreKey;
        valueBase64: StoreValue;
      };
      /** @enum {string} */
      type: 'data_update';
    }
  | {
      change: {
        accountId: AccountId;
        keyBase64: StoreKey;
      };
      /** @enum {string} */
      type: 'data_deletion';
    }
  | {
      change: {
        accountId: AccountId;
        codeBase64: string;
      };
      /** @enum {string} */
      type: 'contract_code_update';
    }
  | {
      change: {
        accountId: AccountId;
      };
      /** @enum {string} */
      type: 'contract_code_deletion';
    }
);
export type StateItem = {
  key: StoreKey;
  value: StoreValue;
};
export type StateSyncConfig = {
  concurrency?: SyncConcurrency;
  /** @description `none` value disables state dump to external storage. */
  dump?: DumpConfig | null;
  sync?: SyncConfig;
};
export type StatusSyncInfo = {
  earliestBlockHash?: CryptoHash | null;
  /** Format: uint64 */
  earliestBlockHeight?: number | null;
  earliestBlockTime?: string | null;
  epochId?: EpochId | null;
  /** Format: uint64 */
  epochStartHeight?: number | null;
  latestBlockHash: CryptoHash;
  /** Format: uint64 */
  latestBlockHeight: number;
  latestBlockTime: string;
  latestStateRoot: CryptoHash;
  syncing: boolean;
};
export type StorageError =
  | 'StorageInternalError'
  | {
      MissingTrieValue: MissingTrieValue;
    }
  | 'UnexpectedTrieValue'
  | {
      StorageInconsistentState: string;
    }
  | {
      FlatStorageBlockNotSupported: string;
    }
  | {
      MemTrieLoadingError: string;
    };
export type StorageGetMode = 'FlatStorage' | 'Trie';
export type StorageUsageConfigView = {
  /**
   * Format: uint64
   * @description Number of bytes for an account record, including rounding up for account id.
   */
  numBytesAccount: number;
  /**
   * Format: uint64
   * @description Additional number of bytes for a k/v record
   */
  numExtraBytesRecord: number;
};
export type StoreKey = string;
export type StoreValue = string;
export type SyncCheckpoint = 'genesis' | 'earliest_available';
export type SyncConcurrency = {
  /**
   * Format: uint8
   * @description Maximum number of "apply parts" tasks that can be performed in parallel.
   *     This is a very disk-heavy task and therefore we set this to a low limit,
   *     or else the rocksdb contention makes the whole server freeze up.
   */
  apply: number;
  /**
   * Format: uint8
   * @description Maximum number of "apply parts" tasks that can be performed in parallel
   *     during catchup. We set this to a very low value to avoid overloading the
   *     node while it is still performing normal tasks.
   */
  applyDuringCatchup: number;
  /**
   * Format: uint8
   * @description Maximum number of outstanding requests for decentralized state sync.
   */
  peerDownloads: number;
  /**
   * Format: uint8
   * @description The maximum parallelism to use per shard. This is mostly for fairness, because
   *     the actual rate limiting is done by the TaskTrackers, but this is useful for
   *     balancing the shards a little.
   */
  perShard: number;
};
export type SyncConfig =
  | 'Peers'
  | {
      ExternalStorage: ExternalStorageConfig;
    };
export type Tier1ProxyView = {
  addr: string;
  peerId: PublicKey;
};
export type TrackedShardsConfig =
  | 'NoShards'
  | {
      Shards: ShardUId[];
    }
  | 'AllShards'
  | {
      ShadowValidator: AccountId;
    }
  | {
      Schedule: ShardId[][];
    }
  | {
      Accounts: AccountId[];
    };
export type TransferAction = {
  deposit: string;
};
export type TxExecutionError =
  | {
      ActionError: ActionError;
    }
  | {
      InvalidTxError: InvalidTxError;
    };
export type TxExecutionStatus =
  | 'NONE'
  | 'INCLUDED'
  | 'EXECUTED_OPTIMISTIC'
  | 'INCLUDED_FINAL'
  | 'EXECUTED'
  | 'FINAL';
export type UseGlobalContractAction = {
  contractIdentifier: GlobalContractIdentifier;
};
export type VMConfigView = {
  /** @description See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections). */
  discardCustomSections: boolean;
  /** @description See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts). */
  ethImplicitAccounts: boolean;
  /** @description Costs for runtime externals */
  extCosts: ExtCostsConfigView;
  /** @description See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost). */
  fixContractLoadingCost: boolean;
  /** @description See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns). */
  globalContractHostFns: boolean;
  /**
   * Format: uint32
   * @description Gas cost of a growing memory by single page.
   */
  growMemCost: number;
  /** @description See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation). */
  implicitAccountCreation: boolean;
  /** @description Describes limits for VM and Runtime.
   *
   *     TODO: Consider changing this to `VMLimitConfigView` to avoid dependency
   *     on runtime. */
  limitConfig: LimitConfig;
  /** @description See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory). */
  reftypesBulkMemory: boolean;
  /**
   * Format: uint32
   * @description Gas cost of a regular operation.
   */
  regularOpCost: number;
  /** @description See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int). */
  saturatingFloatToInt: boolean;
  /** @description See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode). */
  storageGetMode: StorageGetMode;
  /** @description See [VMConfig::vm_kind](crate::vm::Config::vm_kind). */
  vmKind: VMKind;
};
export type VMKind = 'Wasmer0' | 'Wasmtime' | 'Wasmer2' | 'NearVm' | 'NearVm2';
export type ValidatorInfo = {
  accountId: AccountId;
};
export type ValidatorKickoutReason =
  | '_UnusedSlashed'
  | {
      NotEnoughBlocks: {
        /** Format: uint64 */
        expected: number;
        /** Format: uint64 */
        produced: number;
      };
    }
  | {
      NotEnoughChunks: {
        /** Format: uint64 */
        expected: number;
        /** Format: uint64 */
        produced: number;
      };
    }
  | 'Unstaked'
  | {
      NotEnoughStake: {
        stakeU128: string;
        thresholdU128: string;
      };
    }
  | 'DidNotGetASeat'
  | {
      NotEnoughChunkEndorsements: {
        /** Format: uint64 */
        expected: number;
        /** Format: uint64 */
        produced: number;
      };
    }
  | {
      ProtocolVersionTooOld: {
        /** Format: uint32 */
        networkVersion: number;
        /** Format: uint32 */
        version: number;
      };
    };
export type ValidatorKickoutView = {
  accountId: AccountId;
  reason: ValidatorKickoutReason;
};
export type ValidatorStakeView = {
  /** @enum {string} */
  validatorStakeStructVersion: 'V1';
} & ValidatorStakeViewV1;
export type ValidatorStakeViewV1 = {
  accountId: AccountId;
  publicKey: PublicKey;
  stake: string;
};
export type Version = {
  build: string;
  commit: string;
  /** @default  */
  rustcVersion: string;
  version: string;
};
export type ViewStateResult = {
  proof?: string[];
  values: StateItem[];
};
export type WasmTrap =
  | 'Unreachable'
  | 'IncorrectCallIndirectSignature'
  | 'MemoryOutOfBounds'
  | 'CallIndirectOOB'
  | 'IllegalArithmetic'
  | 'MisalignedAtomicAccess'
  | 'IndirectCallToNull'
  | 'StackOverflow'
  | 'GenericTrap';
export type WitnessConfigView = {
  /**
   * Format: uint
   * @description Maximum size of transactions contained inside ChunkStateWitness.
   *
   *     A witness contains transactions from both the previous chunk and the current one.
   *     This parameter limits the sum of sizes of transactions from both of those chunks.
   */
  combinedTransactionsSizeLimit: number;
  /**
   * Format: uint64
   * @description Size limit for storage proof generated while executing receipts in a chunk.
   *     After this limit is reached we defer execution of any new receipts.
   */
  mainStorageProofSizeSoftLimit: number;
  /**
   * Format: uint64
   * @description Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.
   */
  newTransactionsValidationStateSizeSoftLimit: number;
};
